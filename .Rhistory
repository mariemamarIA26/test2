V <- seq(2, 20, 2)
V
W <- rep(-1,10)
W
V%%W
V*W
M= matrix  (data= c(V,W), nrow=2, byrow=TRUE)
M
M= matrix  (data= c(V,W), nrow=10, byrow=TRUE)
M
M= matrix  (data= c(V,W), nrow=10, byrow=FALSE)
M
H= M
H= [1:2, 1:2] <- 0
H=[1:2, 1:2] <- 0
H=[1:2,1:2] <- 0
H[1:2,1:2] <- 0
H
M+2
2*M
M/5
M+H
M(-c(9,10))
M(-4,-5)
M[-4,-5]
M[-4:-5]
M[-4,-5]
M <- M[-4:-5,]
M
M[nrow(M):1,]
## TP4: Exercices
#1)
V <- seq(2, 20, 2)
V
W <- rep(-1,10)
W
V*W
M= matrix  (data= c(V,W), nrow=10, byrow=FALSE)
M
H= M
H[1:2,1:2] <- 0
H
M+2
2*M
M/5
M+H
M <- M[-4:-5,]
M
M[nrow(M):1,]
M
M[1,] <- sort (M[1,])
M
M <-  A <- matrix( c(5, 1, 0,
3,-1, 2,
4, 0,-1), nrow=3, byrow=TRUE)
M
det(M)
H <- inv(M)
(H <- inv(M))
H <- inv(M)
H <- solve(M)
H
H*M
M*H
det(H)
eigen(M)
eigen(M)$val
#3)
m1 <- c(0, -1)
m2 <-  c(1,0)
A <- rbind(m1,m2)
A
eigen(A)$val
m3 -> c(2,4)
m4 -> c(4,0)
m3 <- c(2,4)
m4 <-c(4,0)
M <-rbind(m3,m4)
eigen(M)
eigen(M)$val
plot(M)
plot(M, main = "data", xlim=c(0,.8), xlab=NA, ylab=NA, type ="n")
arrows(x0 = 0, y0 = 0, x1 = dat[1,1], y1 = dat[2,1], lwd = 5, col="purple")
arrows(x0 = 0, y0 = 0, x1 = dat[1,2], y1 = dat[2,2], lwd = 5, col="orange")
plot(M, main = "data", xlab=NA, ylab=NA, type ="n")
plot(M, main = "data", xlab=NA, ylab=NA, type ="n")
arrows(x0 = 0, y0 = 0, x1 = dat[1,1], y1 = dat[2,1], lwd = 5, col="purple")
arrows(x0 = 0, y0 = 0, x1 = dat[1,2], y1 = dat[2,2], lwd = 5, col="orange")
plot (M)
N <- eigen(M)$val
plot (M)
vector <- eigen(M)
vector
plot (M)
plot (vector)
vector <- eigen(M)$val
vector
plot (vector)
plot.default(vector)
#1)
V <- seq(2, 20, 2)
V
W <- rep(-1,10)
W
V*W
M= matrix  (data= c(V,W), nrow=10, byrow=FALSE)
M
H= M
H[1:2,1:2] <- 0
H
M+2
2*M
M/5
M+H
M <- M[-4:-5,]
M
M[nrow(M):1,]
M
M[1,] <- sort (M[1,])
M
#2)
M <-  A <- matrix( c(5, 1, 0,
3,-1, 2,
4, 0,-1), nrow=3, byrow=TRUE)
M
det(M)
H <- solve(M)
H
H*M
M*H
det(H)
# non il ne vaut pas l'inverse  de M
eigen(M)$val
#3)
m1 <- c(0, -1)
m2 <-  c(1,0)
A <- rbind(m1,m2)
A
eigen(A)$val
# Impossible de calculer les valeurs propres d'une matrice non diagonalisable car il s'agit de valeurs complexes.
#4)
m3 <- c(2,4)
m4 <-c(4,0)
M <-rbind(m3,m4)
vector <- eigen(M)$val
vector
plot.default(vector)
#5)
#1. 2.
library(pracma)
M <- rbind(c(1,0), c(0,0))
M
# Kernel
Ker<-nullspace(t(M))
Ker
BasisKer <-rref(Ker)
BasisKer
Img <- orth(M)
Img
#5)
#1. 2.
library(pracma)
M <- rbind(c(1,0), c(0,0))
M
# Kernel
Ker<-nullspace(t(M))
Ker
BasisKer <-rref(Ker)
BasisKer
Img <- orth(M)
Img
#5)
#1. 2.
library(pracma)
M <- rbind(c(1,0), c(0,0))
M
# Kernel
Ker<-nullspace(t(M))
Ker
BasisKer <-rref(Ker)
BasisKer
Img <- orth(M)
Img
#5)
#1. 2.
library(pracma)
M <- rbind(c(1,0), c(0,0))
M
# Kernel
Ker<-nullspace(t(M))
Ker
BasisKer <-rref(Ker)
BasisKer
Img <- orth(M)
Img
#5)
#1. 2.
library(pracma)
M <- rbind(c(1,0), c(0,0))
M
# Kernel
Ker<-nullspace(t(M))
Ker
BasisKer <-rref(Ker)
BasisKer
Img <- orth(M)
Img
#5)
#1. 2.
library(pracma)
M <- rbind(c(1,0), c(0,0))
M
# Kernel
Ker<-nullspace(t(M))
Ker
BasisKer <-rref(Ker)
BasisKer
Img <- orth(M)
Img
X <- c(5,2000)
M*X
M^2 * X
V1 <- c(Img[1])
V2 <- c(Img[2])
V2
X <- c(5,2000)
M*X
M^2 * X
V1<- c(Img[1])
V2<- c(Img[2])
V2
f1 <- factor(c(1, 22, 1, 1, 2, 2))
f2 <- factor(c("m", "f", "f", "m", "m", NA, "f", "f"))
f1 <- factor(c(1, 22, 1, 1, 2, 2))
f2 <- factor(c("m", "f", "f", "m", "m", NA, "f", "f"))
f1.levels
levels(f1)
levels(f2)
#2.
couleurs <- factor(c("bleu","marron","vert","marron","marron","bleu","marron","marron","vert","vert","marron","vert"))
levels(couleurs)
table(couleurs)
prop.table(couleurs)
coul <- table(couleurs)
prop.table(coul)
cumsum(couleurs)
cumsum(coul)
table(couleurs,addmargins())
addmargins(table(couleurs))
prop.table(coul,3)
round(prop.table(coul),3)
#TP 5: Importation de données et variables qualitatives:
#Exercice 1
#1.Créer et manipuler les facteurs suivants (levels, tableaux d’effectifs).
f1 <- factor(c(1, 22, 1, 1, 2, 2))
levels(f1)
table(f1)
f2 <- factor(c("m", "f", "f", "m", "m", NA, "f", "f"))
levels(f2)
table(f2)
#2. On collecte l’information sur la couleur des yeux de 12 personnes.
# Créer un facteur couleurs regroupant les 12 valeurs obtenues : bleu, marron,vert, marron, marron, bleu, marron, marron, vert, vert, marron, vert.
couleurs <- factor(c("bleu","marron","vert","marron","marron","bleu","marron","marron","vert","vert","marron","vert"))
#Donner les commandes renvoyant le nombre de modalités de la variable étudiée et l’effectif total.
levels(couleurs)
addmargins(table(couleurs))
#Construire le tableau des fréquences arrondies au centième.
coul <- table(couleurs)
round(prop.table(coul),3)
round(prop.table(coul),2)
df <- read_csv("notes.csv")
lien <- "http://egallic.fr/Enseignement/R/Exercices/donnees/notes.csv"
download.file(lien, destfile = "./notes.csv")
df <- read.csv("notes.csv")
library(readr)
df <- read_csv("notes.csv")
#1. Télécharger le fichier csv à l’adresse suivante : egallic.fr/Enseignement/R/Exercices/donnees/notes.csv et le placer dans le répertoire courant du projet. Importer son contenu dans R ;
install.packages("read_csv")
lien <- "http://egallic.fr/Enseignement/R/Exercices/donnees/notes.csv"
download.file(lien, destfile = "./notes.csv")
df <- read.csv("notes.csv")
#1. Créer ce vecteur dans R et le stocker dans un objet que l’on appellera x ;
x <- seq(1, 5)
#1. Créer ce vecteur dans R et le stocker dans un objet que l’on appellera x ;
x <- seq(1, 5)
x
mode(x)
length(x)
#3. Extraire le premier élément, puis le dernier ;
"["(x,1) ; "["(x,5)
#3. Extraire le premier élément, puis le dernier ;
"["(x,1)
"["(x,5)
#4. Extraire les trois premier éléments et les stocker dans un vecteur que l’on nommera a ;
a <- x[1:3]
a
b <- x[c(1,3,5)]
b
(x + 10)*2
a+b
#8. Effectuer l’addition suivante : x+a, commenter le résultat, puis regarder le résultat de a+x ;
x+a
a+x
c <- 2
x*c
a*b
x*a
ind <- which(x %% 2 == 0)
(mult_2 <- x[ind])
x[which(x %% 2 == 0 & x %% 3 == 0)]
x[which(x %% 2 == 0 | x %% 3 == 0)]
sum(x)
x[1] <- 4
x
#17. Remplacer le premier élément de x par la valeur NA, puis calculer la somme des éléments de x ;
x[1] <- NA sum(x)
x[1] <- NA
sum(x, na.rm=TRUE)
ls()
rm(x)
rm(list=ls())
#Evaluation
#Exercise (manupulation de vecteurs)
# Considérons le vecteur suivant : x = [1 2 3 4 5]
#1. Créer ce vecteur dans R et le stocker dans un objet que l’on appellera x ;
x <- seq(1, 5)
x
#2. Afficher le mode de x, puis sa longueur ;
mode(x)
length(x)
#3. Extraire le premier élément, puis le dernier ;
x[1] # Premier élement
x[5] #Dernier élement
#4. Extraire les trois premier éléments et les stocker dans un vecteur que l’on nommera a ;
a <- x[1:3]
a
#5. Extraire les éléments en position 1, 3, 5 ; les stocker dans un vecteur que l’on nommera b ;
b <- x[c(1,3,5)]
b
#6. Additionner le nombre 10 au vecteur x, puis multipliser le résultat par 2 ;
(x + 10)*2
#7. Effectuer l’addition de a et b, commenter le résultat ;
a+b
#Chaque élement de a est additionné à l'élement de b du même rang, successivement.
#8. Effectuer l’addition suivante : x+a, commenter le résultat, puis regarder le résultat de a+x ;
x+a
a+x
#Vu que la longueur de a est inférieure à celle de x, le logiciel affiche un message d'erreur pour nous avertir du fait que il prend le vecteur le plus court et le répête jusqu'à l'obtention d'un vecteur de même longueur que celui qui est long
#Pour pouvoir effectuer le calcul, d'où l'obtention d'un vecteur de longueur 5 comme celle de x.
#9. Multiplier le vecteur par le scalaire c que l’on fixera à 2 ;
c <- 2
x*c
#10. Effectuer la multiplication de a et b, commenter le résultat ;
a*b
#Chaque élement de a est multiplié à l'élement de b du même rang,successivement.
#11. Effectuer la multiplication suivante : x*a, commenter le résultat ;
x*a
#Vu que la longueur de a est inférieure à celle de x, le logiciel affiche un message d'erreur pour nous avertir du fait qu'il prend le vecteur le plus court et le répête jusqu'à l'obtention d'un vecteur de même longueur que celui qui est long
#Pour pouvoir effectuer le calcul, d'où l'obtention d'un vecteur de longueur 5 comme celle de x.
#12. Récupérer les positions des multiples de 2 et les stocker dans un vecteur que l’on nommera ind,puis conserver uniquement les multiples de 2 de x dans un vecteur que l’on nommera mult_2 ;
ind <- which(x %% 2 == 0)
(mult_2 <- x[ind])
#13. Afficher les éléments de x qui sont multiples de 3 et multiples de 2 ;
x[which(x %% 2 == 0 & x %% 3 == 0)]
#14. Afficher les éléments de x qui sont multiples de 3 ou multiples de 2 ;
x[which(x %% 2 == 0 | x %% 3 == 0)]
#15. Calculer la somme des éléments de x ;
sum(x)
#16. Remplacer le premier élément de x par un 4 ;
x[1] <- 4
x
#17. Remplacer le premier élément de x par la valeur NA, puis calculer la somme des éléments de x ;
x[1] <- NA
sum(x, na.rm=TRUE)
#18. Lister les objets en mémoire dans la session R ;
ls()
#19. Supprimer le vecteur ;
rm(x)
#20. Supprimer la totalité des objets de la session.
rm(list=ls())
x[which(x %% 2 == 0 & x %% 3 == 0)]
#1. Créer ce vecteur dans R et le stocker dans un objet que l’on appellera x ;
x <- seq(1, 5)
x
#2. Afficher le mode de x, puis sa longueur ;
mode(x)
length(x)
#3. Extraire le premier élément, puis le dernier ;
x[1] # Premier élement
x[5] #Dernier élement
#4. Extraire les trois premier éléments et les stocker dans un vecteur que l’on nommera a ;
a <- x[1:3]
a
#5. Extraire les éléments en position 1, 3, 5 ; les stocker dans un vecteur que l’on nommera b ;
b <- x[c(1,3,5)]
b
#6. Additionner le nombre 10 au vecteur x, puis multipliser le résultat par 2 ;
(x + 10)*2
#7. Effectuer l’addition de a et b, commenter le résultat ;
a+b
#Chaque élement de a est additionné à l'élement de b du même rang, successivement.
#8. Effectuer l’addition suivante : x+a, commenter le résultat, puis regarder le résultat de a+x ;
x+a
a+x
#Vu que la longueur de a est inférieure à celle de x, le logiciel affiche un message d'erreur pour nous avertir du fait que il prend le vecteur le plus court et le répête jusqu'à l'obtention d'un vecteur de même longueur que celui qui est long pour pouvoir effectuer le calcul, d'où l'obtention d'un vecteur de longueur 5 comme celle de x.
#9. Multiplier le vecteur par le scalaire c que l’on fixera à 2 ;
c <- 2
x*c
#10. Effectuer la multiplication de a et b, commenter le résultat ;
a*b
#Chaque élement de a est multiplié à l'élement de b du même rang,successivement.
#11. Effectuer la multiplication suivante : x*a, commenter le résultat ;
x*a
#Vu que la longueur de a est inférieure à celle de x, le logiciel affiche un message d'erreur pour nous avertir du fait qu'il prend le vecteur le plus court et le répête jusqu'à l'obtention d'un vecteur de même longueur que celui qui est long pour pouvoir effectuer le calcul, d'où l'obtention d'un vecteur de longueur 5 comme celle de x.
#12. Récupérer les positions des multiples de 2 et les stocker dans un vecteur que l’on nommera ind,puis conserver uniquement les multiples de 2 de x dans un vecteur que l’on nommera mult_2 ;
ind <- which(x %% 2 == 0)
ind
(mult_2 <- x[ind])
mult_2
#13. Afficher les éléments de x qui sont multiples de 3 et multiples de 2 ;
x[which(x %% 2 == 0 & x %% 3 == 0)]
#14. Afficher les éléments de x qui sont multiples de 3 ou multiples de 2 ;
x[which(x %% 2 == 0 | x %% 3 == 0)]
#15. Calculer la somme des éléments de x ;
sum(x)
#16. Remplacer le premier élément de x par un 4 ;
x[1] <- 4
x
#17. Remplacer le premier élément de x par la valeur NA, puis calculer la somme des éléments de x ;
x[1] <- NA
sum(x, na.rm=TRUE)
#18. Lister les objets en mémoire dans la session R ;
ls()
#19. Supprimer le vecteur ;
rm(x)
#20. Supprimer la totalité des objets de la session.
rm(list=ls())
#Evaluation AMAR Mariem
#Exercise (manupulation de vecteurs)
# Considérons le vecteur suivant : x = [1 2 3 4 5]
#1. Créer ce vecteur dans R et le stocker dans un objet que l’on appellera x ;
x <- seq(1, 5)
x
#2. Afficher le mode de x, puis sa longueur ;
mode(x)
length(x)
#3. Extraire le premier élément, puis le dernier ;
x[1] # Premier élement
x[5] #Dernier élement
#4. Extraire les trois premier éléments et les stocker dans un vecteur que l’on nommera a ;
a <- x[1:3]
a
#5. Extraire les éléments en position 1, 3, 5 ; les stocker dans un vecteur que l’on nommera b ;
b <- x[c(1,3,5)]
b
#6. Additionner le nombre 10 au vecteur x, puis multipliser le résultat par 2 ;
(x + 10)*2
#7. Effectuer l’addition de a et b, commenter le résultat ;
a+b
#Chaque élement de a est additionné à l'élement de b du même rang, successivement.
#8. Effectuer l’addition suivante : x+a, commenter le résultat, puis regarder le résultat de a+x ;
x+a
a+x
#Vu que la longueur de a est inférieure à celle de x, le logiciel affiche un message d'erreur pour nous avertir du fait que il prend le vecteur le plus court et le répête jusqu'à l'obtention d'un vecteur de même longueur que celui qui est long pour pouvoir effectuer le calcul, d'où l'obtention d'un vecteur de longueur 5 comme celle de x.
#9. Multiplier le vecteur par le scalaire c que l’on fixera à 2 ;
c <- 2
x*c
#10. Effectuer la multiplication de a et b, commenter le résultat ;
a*b
#Chaque élement de a est multiplié à l'élement de b du même rang,successivement.
#11. Effectuer la multiplication suivante : x*a, commenter le résultat ;
x*a
#Vu que la longueur de a est inférieure à celle de x, le logiciel affiche un message d'erreur pour nous avertir du fait qu'il prend le vecteur le plus court et le répête jusqu'à l'obtention d'un vecteur de même longueur que celui qui est long pour pouvoir effectuer le calcul, d'où l'obtention d'un vecteur de longueur 5 comme celle de x.
#12. Récupérer les positions des multiples de 2 et les stocker dans un vecteur que l’on nommera ind,puis conserver uniquement les multiples de 2 de x dans un vecteur que l’on nommera mult_2 ;
ind <- which(x %% 2 == 0)
ind
(mult_2 <- x[ind])
mult_2
#13. Afficher les éléments de x qui sont multiples de 3 et multiples de 2 ;
x[which(x %% 2 == 0 & x %% 3 == 0)]
#14. Afficher les éléments de x qui sont multiples de 3 ou multiples de 2 ;
x[which(x %% 2 == 0 | x %% 3 == 0)]
#15. Calculer la somme des éléments de x ;
sum(x)
#16. Remplacer le premier élément de x par un 4 ;
x[1] <- 4
x
#17. Remplacer le premier élément de x par la valeur NA, puis calculer la somme des éléments de x ;
x[1] <- NA
sum(x, na.rm=TRUE)
#18. Lister les objets en mémoire dans la session R ;
ls()
#19. Supprimer le vecteur ;
rm(x)
#20. Supprimer la totalité des objets de la session.
rm(list=ls())
library(shiny)
pip shiny
pip (shiny)
pip install shiny
library(shiny)
library(shiny)
library(shiny)
library(shiny)
library(shiny)
ui <- fluidPage(
)
server <- function(input, output, session) {
}
shinyApp(ui, server)
library(shiny)
runApp('Name')
